package com.notification.ratelimit;

import com.notification.config.NotificationConfig;
import com.notification.service.EnhancedNotificationService;
import com.notification.service.NotificationService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;

/**
 * 限流通知服务包装器
 * 使用令牌桶算法实现通知发送频率限制
 */
public class RateLimitedNotificationService implements EnhancedNotificationService {\n    \n    private static final Logger logger = LoggerFactory.getLogger(RateLimitedNotificationService.class);\n    \n    private final NotificationService delegate;\n    private final TokenBucket tokenBucket;\n    private final AtomicLong rejectedCount = new AtomicLong(0);\n    private final AtomicLong totalRequests = new AtomicLong(0);\n    \n    public RateLimitedNotificationService(NotificationService delegate) {\n        this.delegate = delegate;\n        NotificationConfig config = NotificationConfig.getInstance();\n        this.tokenBucket = new TokenBucket(\n            config.getRateLimitPermits(), \n            config.getRateLimitPeriod()\n        );\n    }\n    \n    public RateLimitedNotificationService(NotificationService delegate, int permits, long periodMillis) {\n        this.delegate = delegate;\n        this.tokenBucket = new TokenBucket(permits, periodMillis);\n    }\n    \n    @Override\n    public boolean sendNotification(String message, String title) {\n        return executeWithRateLimit(() -> delegate.sendNotification(message, title), \n                                   \"sendNotification\");\n    }\n    \n    @Override\n    public boolean sendTaskCompletionNotification(String taskName, String status, long duration) {\n        return executeWithRateLimit(() -> delegate.sendTaskCompletionNotification(taskName, status, duration),\n                                   \"sendTaskCompletionNotification\");\n    }\n    \n    @Override\n    public boolean sendErrorNotification(String taskName, String errorMessage) {\n        return executeWithRateLimit(() -> delegate.sendErrorNotification(taskName, errorMessage),\n                                   \"sendErrorNotification\");\n    }\n    \n    @Override\n    public CompletableFuture<SendResult> sendNotificationAsync(NotificationMessage message) {\n        return CompletableFuture.supplyAsync(() -> {\n            if (!tokenBucket.tryConsume()) {\n                rejectedCount.incrementAndGet();\n                return new SendResult(false, message.getMessageId(), \"请求被限流\", 0);\n            }\n            \n            totalRequests.incrementAndGet();\n            if (delegate instanceof EnhancedNotificationService) {\n                return ((EnhancedNotificationService) delegate).sendNotificationAsync(message).join();\n            } else {\n                long startTime = System.currentTimeMillis();\n                boolean success = delegate.sendNotification(message.getContent(), message.getTitle());\n                long duration = System.currentTimeMillis() - startTime;\n                return new SendResult(success, message.getMessageId(), success ? null : \"发送失败\", duration);\n            }\n        });\n    }\n    \n    @Override\n    public CompletableFuture<SendResult> sendNotificationAsync(String message, String title, Priority priority) {\n        NotificationMessage msg = new NotificationMessage(title, message, priority);\n        return sendNotificationAsync(msg);\n    }\n    \n    @Override\n    public List<SendResult> sendBatchNotifications(List<NotificationMessage> messages) {\n        return messages.stream()\n                .map(msg -> {\n                    if (!tokenBucket.tryConsume()) {\n                        rejectedCount.incrementAndGet();\n                        return new SendResult(false, msg.getMessageId(), \"请求被限流\", 0);\n                    }\n                    \n                    totalRequests.incrementAndGet();\n                    if (delegate instanceof EnhancedNotificationService) {\n                        EnhancedNotificationService enhanced = (EnhancedNotificationService) delegate;\n                        return enhanced.sendBatchNotifications(List.of(msg)).get(0);\n                    } else {\n                        long startTime = System.currentTimeMillis();\n                        boolean success = delegate.sendNotification(msg.getContent(), msg.getTitle());\n                        long duration = System.currentTimeMillis() - startTime;\n                        return new SendResult(success, msg.getMessageId(), success ? null : \"发送失败\", duration);\n                    }\n                })\n                .collect(java.util.stream.Collectors.toList());\n    }\n    \n    @Override\n    public CompletableFuture<List<SendResult>> sendBatchNotificationsAsync(List<NotificationMessage> messages) {\n        return CompletableFuture.supplyAsync(() -> sendBatchNotifications(messages));\n    }\n    \n    @Override\n    public boolean sendNotificationWithPriority(String message, String title, Priority priority) {\n        // 根据优先级决定是否跳过限流\n        if (priority == Priority.URGENT) {\n            // 紧急消息跳过限流\n            totalRequests.incrementAndGet();\n            if (delegate instanceof EnhancedNotificationService) {\n                return ((EnhancedNotificationService) delegate).sendNotificationWithPriority(message, title, priority);\n            } else {\n                return delegate.sendNotification(message, title);\n            }\n        }\n        \n        return executeWithRateLimit(() -> {\n            if (delegate instanceof EnhancedNotificationService) {\n                return ((EnhancedNotificationService) delegate).sendNotificationWithPriority(message, title, priority);\n            } else {\n                return delegate.sendNotification(message, title);\n            }\n        }, \"sendNotificationWithPriority\");\n    }\n    \n    @Override\n    public boolean sendTaskCompletionNotification(String taskName, String status, long duration, Priority priority) {\n        return executeWithRateLimit(() -> {\n            if (delegate instanceof EnhancedNotificationService) {\n                return ((EnhancedNotificationService) delegate).sendTaskCompletionNotification(taskName, status, duration, priority);\n            } else {\n                return delegate.sendTaskCompletionNotification(taskName, status, duration);\n            }\n        }, \"sendTaskCompletionNotification\");\n    }\n    \n    @Override\n    public CompletableFuture<SendResult> sendDelayedNotification(String message, String title, long delayMillis) {\n        if (delegate instanceof EnhancedNotificationService) {\n            return ((EnhancedNotificationService) delegate).sendDelayedNotification(message, title, delayMillis);\n        } else {\n            return CompletableFuture.supplyAsync(() -> {\n                try {\n                    Thread.sleep(delayMillis);\n                    if (!tokenBucket.tryConsume()) {\n                        rejectedCount.incrementAndGet();\n                        return new SendResult(false, \"delayed_\" + System.currentTimeMillis(), \"延迟发送被限流\", 0);\n                    }\n                    totalRequests.incrementAndGet();\n                    long startTime = System.currentTimeMillis();\n                    boolean success = delegate.sendNotification(message, title);\n                    long duration = System.currentTimeMillis() - startTime;\n                    return new SendResult(success, \"delayed_\" + System.currentTimeMillis(), \n                                        success ? null : \"延迟发送失败\", duration);\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                    return new SendResult(false, \"delayed_\" + System.currentTimeMillis(), \"延迟发送被中断\", 0);\n                }\n            });\n        }\n    }\n    \n    @Override\n    public CompletableFuture<SendResult> sendScheduledNotification(String message, String title, long scheduleTime) {\n        long delay = scheduleTime - System.currentTimeMillis();\n        if (delay <= 0) {\n            return sendNotificationAsync(message, title, Priority.NORMAL);\n        }\n        return sendDelayedNotification(message, title, delay);\n    }\n    \n    @Override\n    public String getServiceStatus() {\n        String delegateStatus = \"\";\n        if (delegate instanceof EnhancedNotificationService) {\n            delegateStatus = ((EnhancedNotificationService) delegate).getServiceStatus();\n        } else {\n            delegateStatus = delegate.getClass().getSimpleName();\n        }\n        \n        return String.format(\"RateLimitedService[delegate=%s, permits=%d, period=%dms, rejected=%d, total=%d, rate=%.2f%%]\",\n                           delegateStatus, tokenBucket.getCapacity(), tokenBucket.getPeriodMillis(),\n                           rejectedCount.get(), totalRequests.get(), \n                           totalRequests.get() > 0 ? (double) rejectedCount.get() / totalRequests.get() * 100 : 0.0);\n    }\n    \n    @Override\n    public boolean testConnection() {\n        if (delegate instanceof EnhancedNotificationService) {\n            return ((EnhancedNotificationService) delegate).testConnection();\n        }\n        // 测试连接不进行限流\n        try {\n            return delegate.sendNotification(\"连接测试\", \"系统测试\");\n        } catch (Exception e) {\n            logger.warn(\"连接测试失败\", e);\n            return false;\n        }\n    }\n    \n    /**\n     * 获取限流统计信息\n     * @return 统计信息\n     */\n    public RateLimitStats getStats() {\n        return new RateLimitStats(\n            totalRequests.get(),\n            rejectedCount.get(),\n            tokenBucket.getAvailableTokens(),\n            tokenBucket.getCapacity()\n        );\n    }\n    \n    /**\n     * 重置统计信息\n     */\n    public void resetStats() {\n        totalRequests.set(0);\n        rejectedCount.set(0);\n    }\n    \n    /**\n     * 执行带限流的操作\n     * @param operation 操作\n     * @param operationName 操作名称\n     * @return 执行结果\n     */\n    private boolean executeWithRateLimit(java.util.function.Supplier<Boolean> operation, String operationName) {\n        totalRequests.incrementAndGet();\n        \n        if (!tokenBucket.tryConsume()) {\n            long rejected = rejectedCount.incrementAndGet();\n            logger.warn(\"操作 {} 被限流拒绝，当前拒绝次数: {}\", operationName, rejected);\n            return false;\n        }\n        \n        return operation.get();\n    }\n    \n    /**\n     * 令牌桶实现\n     */\n    private static class TokenBucket {\n        private final int capacity;\n        private final long periodMillis;\n        private final Semaphore semaphore;\n        private volatile long lastRefillTime;\n        \n        public TokenBucket(int capacity, long periodMillis) {\n            this.capacity = capacity;\n            this.periodMillis = periodMillis;\n            this.semaphore = new Semaphore(capacity);\n            this.lastRefillTime = System.currentTimeMillis();\n            \n            // 启动令牌补充线程\n            startRefillThread();\n        }\n        \n        public boolean tryConsume() {\n            return semaphore.tryAcquire();\n        }\n        \n        public int getAvailableTokens() {\n            return semaphore.availablePermits();\n        }\n        \n        public int getCapacity() {\n            return capacity;\n        }\n        \n        public long getPeriodMillis() {\n            return periodMillis;\n        }\n        \n        private void startRefillThread() {\n            Thread refillThread = new Thread(() -> {\n                while (true) {\n                    try {\n                        Thread.sleep(periodMillis);\n                        refill();\n                    } catch (InterruptedException e) {\n                        Thread.currentThread().interrupt();\n                        break;\n                    }\n                }\n            }, \"token-bucket-refill\");\n            refillThread.setDaemon(true);\n            refillThread.start();\n        }\n        \n        private void refill() {\n            long now = System.currentTimeMillis();\n            if (now - lastRefillTime >= periodMillis) {\n                int tokensToAdd = capacity - semaphore.availablePermits();\n                if (tokensToAdd > 0) {\n                    semaphore.release(tokensToAdd);\n                }\n                lastRefillTime = now;\n            }\n        }\n    }\n    \n    /**\n     * 限流统计信息\n     */\n    public static class RateLimitStats {\n        private final long totalRequests;\n        private final long rejectedRequests;\n        private final int availableTokens;\n        private final int capacity;\n        \n        public RateLimitStats(long totalRequests, long rejectedRequests, int availableTokens, int capacity) {\n            this.totalRequests = totalRequests;\n            this.rejectedRequests = rejectedRequests;\n            this.availableTokens = availableTokens;\n            this.capacity = capacity;\n        }\n        \n        public long getTotalRequests() { return totalRequests; }\n        public long getRejectedRequests() { return rejectedRequests; }\n        public int getAvailableTokens() { return availableTokens; }\n        public int getCapacity() { return capacity; }\n        \n        public double getRejectionRate() {\n            return totalRequests > 0 ? (double) rejectedRequests / totalRequests : 0.0;\n        }\n        \n        @Override\n        public String toString() {\n            return String.format(\"RateLimitStats{total=%d, rejected=%d, available=%d/%d, rate=%.2f%%}\",\n                               totalRequests, rejectedRequests, availableTokens, capacity, getRejectionRate() * 100);\n        }\n    }\n}